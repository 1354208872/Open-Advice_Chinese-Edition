\chapterwithauthor{Thom May}{Packaging - Providing a Great Route into Free Software}

\authorbio{Thom May is a Debian Developer, an emeritus Member of the Apache
Software Foundation and was one of the first hires for Canonical, Ubuntu's
parent company. He currently lives in London and is Head of DevOps for Macmillan
Digital Science.}

\section*{Introduction}
I started out in Free Software over a decade ago. I had been using Debian for
some years through university, and decided that I wanted to give something back.
So I started the long journey through the Debian New Maintainer's process, never
having really contributed to Free Software before, and concerned that a lack of
experience with C would prove to be a major problem.

十多年前我开始使用自由软件。大学这几年我一直使用Debian这种操作系统,然后决定给与一些回馈。
所以我开始做一个长时期的Debian操作系统的维护者,但是之前没有与自由软件相关的工作经验，
而且考虑到对C语言缺乏经验，这是一个非常严重的问题。 

As it turned out, this concern was mostly unfounded. By starting out working
with packages that I used regularly I was able to contribute effectively. As my
experience with the myriad of tools and systems that Debian provides to its
maintainers grew, I became more efficient with my time, and was able to take on
a wider range of packages. 

事实证明，这种担心大部分是杞人忧天，通过接触我经常使用的程序包，我对e_ectively也作出一些贡献。
随着我在使用大量工具和系统的过程中，经验不断增长，Debian操作系统的维护者也不断增多，
这样让我有更多的时间接触e_cient，并能着手做更大范围的程序包。

Taking on more packages increased my exposure to a range of build systems,
programming languages and toolkits, and also helped to bring me into the Debian
community. Abrasive and opinionated though it is, Debian's community of skilled
and experienced maintainers is one of the main reasons Debian has maintained its
technical excellence over such a long period.

揽下更大程序包的工作，让我进一步接触了一系列的构建系统，编程语言和工具包，
也把我带入了Debian系统这个团队。即使这个团队的人针锋相对且固执己见，
但是精湛的技术和丰富经验的人才，是Debian系统长时间保持卓越技术的最主要原因之一。

At about this time the Apache httpd project was finally closing in on the first
beta releases of httpd 2.0, which had been several years in the making and was
going to be a massive upgrade. Debian's Apache team had been fairly inactive for
some time -- the 1.3 packages were stable and changed infrequently -- and had no
plans for packaging 2.0. 
I had a strong interest in ensuring that the httpd packages were well maintained
-- I was working as a sysadmin in charge of numerous Apache web servers -- so it
made a lot of sense to take on the challenge of producing packages for the new
release. 

最近Apache httpd计划在httpd 2.0的公测版本将要结束，这个计划已经运行了几年而且即将大规模升级。
Debian的阿帕奇队伍已经有一段相当长的时间没有更新版本了（1.3的版本很稳定，
没有啥变化（因此在2.0版本上并没有计划去进行包装，作为一个httpd软件包的维护者，
我确保现有的版本保持稳定）我作为系统管理员，负责无数的Apache Web服务器的工作非常喜欢。
对我承担生产和包装的新版本带来了很大挑战，我觉得这是很有意义的）

A friend and I started work on the packages and quickly discovered that while
the code was approaching an early beta quality, the tooling around the build and
customization of httpd was sadly lacking, which is fairly typical for many
complex software projects. 

我和一个朋友开始研究程序包，我们很快发现，当编码接近早期测试的质量时，
围绕构建的工具和httpd的客制化服务正明显的不足，这对于许多复杂的软件项目来说是非常典型的。

Over the course of the best part of a year -- whilst upstream stabilised their
code and an increasing number of early adopters began to test and deploy the new
release -- we worked hard to ensure that the build system was sufficiently
flexible and robust to cope with the stringent requirements of Debian's policy.
As well as ensuring that our packages were technically correct, we had to ensure
that our relationship with upstream allowed us to get patches back upstream
whenever possible, and to get a heads up whenever security issues arose and for
early testing of release candidates. 

过去的一年中最好的环节，{当上游稳定他们的代码时，有越来越多的早期尝试者开始测试和部署新版本，
{我们努力工作，以确保构建系统是高效灵活和强大的，用来应对Debian的政策的严格要求。
并确保我们的包在技术上是正确的，我们必须确保我们与上游关系，使我们能够尽可能恢复补丁，
为了安全问题产生有足够的警惕和早期测定的候选版本。

My interactions with Apache in the course of packaging and maintaining httpd 2.0
led me to become an upstream committer on the project, meaning I could
contribute code directly. This is generally the final step in moving from
packaging software to actively developing it for a wider audience than your
distribution. On a personal level, this recognition gave me the confidence to
contribute to far more Free Software projects, since I knew that my code was of
sufficient quality to be welcomed. 

\section*{Evolution - from packager to developer}
So how did this happen? Packaging in its simplest form ensures that a given
software project complies with the policy of the distribution; in my case
Debian. Generally, this means configuring the software at build time so that
files are placed in the correct directory locations (specified by the File
Hierarchy Standard, or FHS), that dependencies on other packages are correctly
specified, and that the software runs successfully on the distribution. 

More complex packaging can require splitting an upstream project into multiple
packages, for example libraries and the header files that allow the user to
compile software against that library are shipped in separate packages, and
platform dependent files can be shipped separately from platform independent
ones. Ensuring that the upstream software correctly deploys in these situations will often require changes to the code. These changes are the first step into active work on a project, rather than the sometimes passive act of packaging. 

Once your package is available in the distribution it is exposed to millions of
potential users. These users are guaranteed to run your software in ways that
neither you, as packager, nor your upstream expected. Unsurprisingly, with many
eyes come many bug reports. Debian, in common with most distributions,
encourages its users to submit bug reports directly to Debian, rather than to
the individual upstream projects. This allows maintainers to triage bug reports
and ensure that the changes made during the packaging process are not the cause
of the reported problem. Often there can be considerable interaction between the
reporter of the problem and the package maintainer before the upstream
developers become involved.

As the package maintainer increases their knowledge of the project, they will be
able to solve most problems directly. The maintainer will often release bug
fixes directly into Debian in parallel with feeding them back upstream, allowing
for swift problem resolution and considerable testing of fixes. Once a fix is
confirmed the maintainer will then work with the upstream project to ensure that
the required changes happen in the upstream, definitive project, so that they
are available to other users of the software.

Providing successful bug fixes on distributions such as Debian is often a
complex art form. Debian runs on many platforms, from IBM mainframes to smart
phones, and the range and breadth of these platform swiftly reveals assumptions
in the code. More often than not the packager has easier access to a broader
range of platforms than upstream does, and so is the first port of call when a
knotty porting problem does come up. One quickly learns to recognise the symptoms of pointer size assumptions, endianness problems, and many other esoteric issues; this experience makes one a more versatile and cautious programmer.

As a package collects bug fixes and improvements, it is essential to feed those
changes back upstream. Too often the delta between a package and the definitive,
upstream software can grow enormously, with the effect that the two become
almost entirely separate code bases. Not only does this increase the maintenance
burden on both sides, but it can cause huge frustration and waste large amounts
of time for your upstream should a user of your package report a bug related to
one of the changes in the packaged version to the upstream. To this end, a close
working relationship with upstream and an understanding of the best way for both
parties to collaborate is vital. 

Collaboration between upstream and packager can take many forms. Whether it be
finding the correct way to communicate bug reports, making sure you use the
correct coding style, or ensuring that you both use the same version control
system in the same way, making sure that your interactions are as friction-free
as possible, makes for a far better relationship with upstream and a greatly
increased likelihood that your upstream will take the time to help you when you
need it. 

Once the working relationship between you and your upstream is established, it
becomes an easy step to contribute more directly to upstream. This, too, can
take many forms. Simple first steps can involve synchronising any upstream bug
reports with the ones from your distribution, making sure that duplicate effort
is not expended to root cause and fix bugs. More direct involvement entails
feature development and changes with a wider scope than would be palatable when
made in a packaged version. 

\section*{Conclusion}
I think the two core things I wish I had known when starting out are the sense
of community that Free Software engenders, and the fantastic route that
packaging of Free Software provides into the wider Free Software world. 

Community is critical to the success of Free Software. It comes in many forms,
from the legion of users willing to invest time in making your software better,
to one’s peers in a distribution or software project who invest their time and
energy into honing your skills and ensuring that your contributions are as good
as possible. 

The route from packaging into development is one often traveled. It provides a
learning curve less steep than entering a development community cold, and allows
one to develop skills at a more gradual rate than would otherwise be the case.  
