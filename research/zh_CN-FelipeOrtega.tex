\chapterwithauthor{费利佩·奥尔特加}{为未来做准备: 自由/开源软件团队的演变}

\authorbio{费利佩·奥尔特加是一位Libresoft的研究者和项目经理, 这是一个西班牙
胡安·卡洛斯国王大学(URJC)的研究小组。费利佩发明了创新的方法来分析开放式协作社区 
(如自由软件项目, 维基百科和社交网络)。他已经在维基百科项目及它的作者社区做了广泛
的研究。 他积极参与自由软件的研究、推广和培训，尤其精通胡安·卡洛斯国王大学(URJC)
的自由软件。他是一个在开放教育资源、开放科学出版入口和开放科学数据上的坚决拥护者。}

\noindent{}在他的著名文章\textit{大教堂和集市}\footnote{\url{
http://www.catb.org/~esr/writings/cathedral-bazaar/cathedral-bazaar}}, 
埃里克.艾斯.雷蒙德评论每个程序员必上的其中第一门课程：”每个好的软件工作都开始于挠开发人员
私人的痒痒。“ 你和永远无法了解到这条语句有多正确除非你自己经历这种情况。事实上，大多数
（如果不是全部）FLOSS的程序员必定在他们着手一个新的品牌项目时候经历过这种过程，。或者他们
加入了一个已经存在的项目，渴望帮助它变得更好。然而，很多在FLOSS社区的开发者和参与者（文档撰
写者、翻译者等等）通常会忽略雷蒙德在他文章后面强调的重要一课：“当你对一个程序失去兴趣后，
你对它最后的责任是把它交给一个称职的继任者”。这是我在这里所表达的中心主题。你应该想想你的项目
的未来，新人有一天会接替你的工作并且不断完善它。

\section*{Generational relay}

At some point in their lifetime, many FLOSS projects must face a generational
relay. Former developers in charge of code maintenance and improvement
eventually leave the project and its community, for a wide variety of reasons.
These include personal issues, a new job that does not leave them enough free
time, starting a new project, switching to a different project that seems more
appealing, \dots\ The list can be pretty long.

The study of generational relay (or developer turnover) in FLOSS projects is
still an emerging area of study that needs further research to improve our
understanding of these situations. In spite of this, some researchers have
already collected objective evidence that sheds some light on these processes.
In OSS 2006, my colleagues Jesus G. Barahona and Gregorio Robles presented a
work entitled ``Contributor Turnover in Libre Software Projects''. In this work,
they show a methodology to identify the most active developers (usually known as
core contributors) in different time intervals, over the whole history of a
given  project. Then, they apply this method to study 21 large projects, in
particular GIMP, Mozilla (former instance of the well-known browser) and
Evolution. In a nutshell, what they found is that we can identify three types of
projects according to their rate of developer turnover:
\begin{itemize}
 \item Code gods projects: These projects heavily rely on the work of their
founders, and there is very little generational relay, or none at all. GIMP
falls into this category.
 \item Projects with multiple generations: Projects like Mozilla show a clear
pattern of developer turnover, with new groups of active developers taking over
the lead of code development and maintenance from the hands of the previous core
contributors.
 \item Composite projects: Evolution belongs to a third category of projects,
showing some rate of turnover but not as evident as in the previous case,
mitigated by retention of some core contributors over the project history.
\end{itemize}

This classification leads us to an obvious question: so, what is the most common
pattern found in real FLOSS projects out there? Well, results for the whole set
of 21 projects analyzed in this work render a clear conclusion, which is that
multiple generations and composite projects are the most common cases found in
the FLOSS ecosystem. Only Gnumeric and Mono showed a distinctive pattern of strong retention of former developers, indicating that people contributing to these projects may have more appealing reasons to continue their work for a long time.

Nevertheless, this is not the normal picture. On the contrary, this study gives
support for the advice we are considering here, that we should prepare to
transfer, at some point in the future, our role and knowledge in the project to
the future contributors joining our community.

\section*{The knowledge gap}

Any person experiencing a significant change in her life must deal with adaption
to new conditions. For example, when you quit your job to get another one you
prepare yourself for a certain period in which you have to fit in a new place,
and integrate yourself in a different working group. Hopefully, after a while
you have finally settled down in your new job. But, sometimes, you keep good
friends from your old job, and you can meet them again after the move. Maybe
then, talking with your former workmates, you can learn what happened with the
person recruited to fill your previous position. This seldom occurs in FLOSS
projects.

The downside of generational relay in FLOSS projects may come in a very concrete
form, namely a knowledge gap. When a former developer leaves the project, and
especially if she had an extensive experience in that community, she leaves
behind both her tangible and abstract knowledge that may or may not be passed
on to subsequent newcomers.

A clear example is source code. Like any product of fine intellectual work
(well, at least one should expect that, right?) developers leave a personal
imprint whenever they produce new code. Sometimes, you feel eternally in debt to
that awesome programmer who wrote neat, elegant code that virtually speaks by
itself and is easily maintainable. Other times, the situation is the opposite
and you struggle to understand very obscure, unclear code without any comments
or hints that can help you.

This is what we tried to measure in 2009, in a research work presented at HICSS
2009. The title is ``Using Software Archeology to Measure Knowledge Loss in
Software Projects Due to Developer Turnover''. In case you were wondering, it has
nothing to do with a whip, treasures, temples or thrilling adventures, though it
was really entertaining. What we measured (among other things) was the
percentage of orphaned code left behind by developers who quit FLOSS projects,
and not taken by any of the current developers, yet. In this case, we choose
four projects (Evolution, GIMP, Evince and Nautilus) to test our research
method. And we found quite interesting results.

Evolution exhibited a somewhat worrying pattern, in the sense that the
percentage of orphaned code was growing over time. By 2006, nearly 80\% of all
source code lines had been abandoned by former developers and remained untouched
by the rest of the team. On the contrary, GIMP showed a radically different
pattern, with a clear and sustained effort of the development team to reduce the
number of orphaned lines of code. By the way, remember that GIMP had already
been characterized  as a code gods project, and thus benefits from a much more
stable development team to undertake this daunting task.

Does this mean that GIMP developers were having a much better experience than
Evolution folks? To be honest, we do not know. Nevertheless, we can foresee a
clear, predictable risk: the higher the percentage of orphaned code, the larger
the effort to maintain the project. Whenever you need to fix a bug, develop a
new feature or extend an existing one, you bump into code you had never seen
before. Of course you may be a fantastic programmer, but no matter how wonderful
you are, GIMP developers do have a clear advantage in this case, since they have
someone in the team with precise knowledge about most of the code they need to
maintain. In addition, they also work to further reduce the portion of unknown
source code over time.

\section*{It feels like home}

Interestingly, some projects manage to retain users for much longer periods than
one could expect. Again, we can find empirical evidence supporting this claim.
In OSS 2005, Michlmayr, Robles and González-Barahona presented some relevant
results pertaining this aspect. They studied the persistence of participation of
software maintainers in Debian, calculating the so-called half-life ratio. This
is the time needed for a certain population of maintainers to fall to half of
its initial size. The result was that the estimated half-life of Debian
maintainers was approximately 7.5 years. In other words, since the study
was undertaken over a period of six and a half years (between July 1998 to
December 2004), comprising from Debian 2.0 to Debian 3.1 (only stable releases),
more than 50\% of maintainers of Debian 2.0 were still contributing to Debian
3.1.

Debian has created quite a formal procedure to admit new software maintainers
(also known as Debian developers) including the acceptance of the Debian Social
Contract and showing good knowledge of Debian Policy. As a result, one would
expect to have quite committed contributors. Actually this is the case, since
these authors found that packages left behind by former maintainers were usually
taken over by other developers staying in the community. Only in those cases in
which the package was not useful anymore it was simply abandoned.
I think we can learn some useful conclusions from these research works:
\begin{enumerate}
 \item Spend some time to develop the main guidelines of your project. It may
start as a single, short document, simply featuring some recommendations and
good practices. This should evolve as the project grows, to serve as a learning
pill for newcomers to quickly grasp the core values of your team, as well as the
main traits of your working style.
 \item Force yourself to follow well-known coding standards, good practices and
elegant style. Document your code. Include comments to describe sections that
might be especially hard to understand. Do not feel that you are wasting your
time. In practice, you are being very pragmatic, investing time in the future of
your project.
 \item If possible, when the time comes for you to quit the project try to make
others aware of your decision some time in advance. Make sure they understand
which critical parts will need a new maintainer. Ideally, if you are a
community, prepare at least a very simple procedure to automate this process and
make sure that you do not forget any important point before that person leaves
the project (especially if she was a key developer).
 \item Keep an eye on the size of orphaned code. If it rises too rapidly, or it
reaches a significant proportion of your project, it is a clear indication that
you will be running into trouble very soon, especially if the number of bug
reports grows or you plan to revamp your code with a serious refactoring.
 \item Always ensure that you leave enough tips and hints for a newcomer to take
over your work in the future.
\end{enumerate}

\section*{I wish I had known you were coming (before I quit)}

I admit it is not very easy to think about your successors while you are
programming. Many times, you just do not realize that your code may end up being
taken over by another project, reused by other people or you might eventually be
replaced by another person, willing to continue your work thereafter.
However, the most remarkable asset of FLOSS is precisely that one: the code will
be reused, adapted, integrated or extended by someone else. Maintainability is a
critical feature of software engineering. But it becomes paramount in FLOSS. It
is not only about source code. It is about people, social relationships and
digital etiquette. It is something beyond mere good taste. Quod severis metes
(``as you sow, so shall you reap''). Remember that, next time, you may be the
newcomer filling the knowledge gap left by a former developer.
